import numpy as np
import scipy.io as sio

def apply2243_calib_vector_iplab(frame_2243, calibmat_path) -> np.ndarray:
    """load and apply the phase and frequency calibration data from the given filename
    TODO: add phase

    Args:
        frame_2243 (np.ndarray): 4D array containing the raw data from AWR2243,
                                 with shape (nsamples, nloops, 16, 12)
        calibmat_path (str): Path of mat file containing the calibration data

    Returns:
        calibratated_frame (np.ndarray): 4D array containing the calibrated data,
                                         with shape (nsamples, nloops, 16, 12)
    """
    # load the calibration matrix
    calib_mat = sio.loadmat(calibmat_path)
    frequency_calibration_vector = calib_mat['caliBatchMat'][0][0][0][0].reshape(-1, 1)
    phase_calibration_vector = calib_mat['caliBatchMat'][0][0][1][0].reshape(-1, 1)

    assert frequency_calibration_vector.shape == (192, 1)
    assert phase_calibration_vector.shape == (192, 1)
    
    # configure reshape parameters
    nloops = frame_2243.shape[1]
    rx2243 = frame_2243.shape[2]
    tx2243 = frame_2243.shape[3]
    nsamples = frame_2243.shape[0]

    # generate n_vec to reshape the data to nsamples for element-wise multiplication
    n_vec = np.arange(nsamples).reshape(-1, 1)

    # element-wise multiplication, result is in shape of (nsamples, nrx*ntx)
    # TODO what does it mean? coloradar - calibration - get_frequency_calibration
    # TODO # generated by copilot: -1j*n_vec is the phase shift caused by the frequency offset
    # VALIDATED SAME BY MATDIFF
    calibration_array = np.exp(-1j*n_vec*frequency_calibration_vector.T) * phase_calibration_vector.T
    # TODO why reshape as (nsamples, 1, nrx, ntx) ?
    calibration_matrix = calibration_array.reshape(nsamples, 1, rx2243, tx2243, order='F')

    # MATLAB version
    # TODO possible reason of reshape: the phase/frequency calibration data is in shape of (1, 192)
    # TODO maybe we can reshape the calibration vector into (12, 16) and then use it directly as well
    # TODO above guess has been verified by following snippet
    # reshape_frame = frame.reshape(frame.shape[0], frame.shape[1], frame.shape[2]*frame.shape[3], order='F')
    # tmp = reshape_frame * np.tile(calibration_array, (1, nloops, 1))
    # np.where(calibratated_frame == tmp[3, 0, 6]) # output: (array([3]), array([0]), array([6]), array([0]))

    # extend the calibration matrix to the number of loops
    calibration_matrix = np.tile(calibration_matrix, (1, nloops, 1, 1))

    calibratated_frame = calibration_matrix * frame_2243

    # # our calibration matrix use complex numbers, so no conversion is needed
    # # phase_cal_mat_arr = np.array(phase_calibration_matrix).astype('float')
    # # phase_cal_mat_arr = phase_cal_mat_arr[:-1:2] + 1j * phase_cal_mat_arr[1::2]
    # # print(phase_cal_mat_arr.shape)
    # phase_calibration_matrix = np.array(phase_calibration_matrix).reshape(num_tx, num_rx)

    # freq_calibration_matrix = np.array(frequency_calibration_matrix).astype('float')
    # freq_calibration_matrix = freq_calibration_matrix.reshape(num_tx, num_rx)
    
    # return phase_calibration_matrix, freq_calibration_matrix
    return calibratated_frame