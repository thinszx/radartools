
'''
@File    :  antennas.py
@Time    :  2023/03/15 11:47:44
@Author  :  Zixin Shang @ thinszx
@Version :  0.1
@Contact :  zxshang@mail.ustc.edu.cn
@Desc    :  This file contains tool functions for loading the virtual array layout
            and converting original ADC data into virtual layout when performing pre-processing.
@Credits :  This file is based on the file
            https://github.com/azinke/coloradar/blob/main/core/calibration.py
'''


import numpy as np

def load_virtual_array_layout(rx_ele, rx_azi, tx_ele, tx_azi) -> tuple[np.ndarray, np.ndarray]:
    """ Loads the virtual array layout from the configuration file.

    Args:
        rx_ele (list): Index of rx antennas in unit of half-wavelengths on elevation direction
        rx_azi (list): Index of rx antennas in unit of half-wavelengths on azimuth direction
        tx_ele (list): Index of tx antennas in unit of half-wavelengths on elevation direction
        tx_azi (list): Index of tx antennas in unit of half-wavelengths on azimuth direction
    
    Returns:
        rxl (numpy.ndarray -> list[list[idx, azi_idx, ele_idx]]): Array describing the configuration of the
            reception antenna in unit of half-wavelengths
        txl (numpy.ndarray -> list[list[idx, azi_idx, ele_idx]]): Array describing the configuration of the
            transmission antenna in unit of half-wavelengths

    NOTE:
        The 'rxl' and 'txl' arrays describe the antenna layout using the
        following structure [idx az, el].

        Thus, the first column indicates the index number of the array.
        The second is the azimuth position of each antenna in half a wave
        length and the last column their elevation position.

        It's important to keep in mind that the row wise ordering of those
        matrices of AWR2243 is [dev4, dev1, dev3, dev2] for the cascade radar.
    """
    # avoid the input is a tuple[list] or nested list
    rx_ele = np.array(rx_ele).flatten()
    rx_azi = np.array(rx_azi).flatten()
    tx_ele = np.array(tx_ele).flatten()
    tx_azi = np.array(tx_azi).flatten()
    
    assert len(rx_ele) == len(rx_azi), 'rx_ele and rx_azi must have the same length, ' \
                                        f'not with length {len(rx_ele)} and {len(rx_azi)}'
    assert len(tx_ele) == len(tx_azi), 'tx_ele and tx_azi must have the same length, ' \
                                        f'not with length {len(tx_ele)} and {len(tx_azi)}'

    rxl = []
    for i in range(len(rx_ele)):
        rxl.append([i, rx_azi[i], rx_ele[i]])
    
    txl = []
    for i in range(len(tx_ele)):
        txl.append([i, tx_azi[i], tx_ele[i]])

    rxl = np.array(rxl)
    txl = np.array(txl)
    return rxl, txl

def adc2virtual_array(adc_samples, rxl, txl, accumulate=False) -> np.ndarray:
    """ Converts the ADC samples to virtual array samples. 
    
    Args:
        adc_samples (numpy.ndarray): The ADC samples with shape (*, nrx, ntx)
        rxl (numpy.ndarray -> list[list[int]]): Rx layout generated by `load_virtual_array_layout`
        txl (numpy.ndarray -> list[list[int]]): Tx layout generated by `load_virtual_array_layout`
        accumulate (bool): Whether to accumulate the samples on overlap antennas, default as False

    Returns:
        The virtual array samples.
        
    NOTE:
        With test, `accumulate=False` will generate the same result as MATLAB
        but as is said in https://github.com/azinke/coloradar/blob/e327fc8f7eaaf5c131789f8d98ad71f53e7acb7c/core/utils/radardsp.py#L109
        `accumulate=True` will enforce the signal received for better SNR
    """
    # load adc as virtual antenna array
    nest_shape: tuple = (
        # adc_samples.shape[0], # number of samples per chirp
        # adc_samples.shape[1], # number of loops per frame
        adc_samples.shape[:-2],
        # Length of the elevation axis
        # the "+1" is to count for the 0-indexing used
        np.max(txl[:, 2]) + np.max(rxl[:, 2]) + 1,
        # Length of the azimuth axis
        # the "+1" is to count for the 0-indexing used
        np.max(txl[:, 1]) + np.max(rxl[:, 1]) + 1,
    )
    va_shape = []
    va_shape = [x for x in nest_shape[0] if x != ()]
    va_shape.extend(nest_shape[1:])
    va_adc = np.zeros(va_shape, dtype=np.complex128)

    for ridx, raz, rel in rxl:
        for tidx, taz, tel in txl:
            if accumulate:
                va_adc[..., tel+rel, taz+raz] += adc_samples[..., ridx, tidx]
            else:
                va_adc[..., tel+rel, taz+raz] = adc_samples[..., ridx, tidx]

    return va_adc